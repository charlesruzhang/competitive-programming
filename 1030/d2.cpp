// By Auchenai01 #include <bits/stdc++.h> using namespace std; using ll = long long; using ld = long double; using pii = pair<int, int>; using pll = pair<ll, ll>; using vi = vector<int>; using vvi = vector<vector<int>>; using vl = vector<ll>; using vvl = vector<vector<ll>>; const ll MOD = 998244353; const ll MAXX = 1e16; class DSU {public: vector<int> parent, size; DSU(int n) {parent.resize(n); size.resize(n, 1); for (int i = 0; i < n; ++i) {parent[i] = i; } } int find(int x) {if (parent[x] != x) {parent[x] = find(parent[x]); } return parent[x]; } void unite(int a, int b) {a = find(a), b = find(b); if (a != b) {if (size[a] < size[b]) swap(a, b); parent[b] = a; size[a] += size[b]; } } }; void solve() {int n; ll k; cin >> n >> k; vl p(n); for (int i = 0; i < n; i++) {cin >> p[i]; } vl d(n); for (int i = 0; i < n; i++) {cin >> d[i]; } map<ll, vi> ma; set<array<ll, 3>> s; for (int i = 0; i < n; i++) {ll z1 = (p[i] - d[i]) % k; if (z1 < 0) z1 += k; ll z2 = (p[i] + d[i]) % k; ma[z1].push_back(i); s.insert({z1, p[i], i}); ma[z2].push_back(n + i); } auto it = ma.begin(); DSU D(2 * n + 1); while (it != ma.end()) {int sz = it -> second.size(); vi valid(sz); vi last(sz+1, -1); for (int i = sz - 1; i >= 0; i --) {int z = it -> second[i]; if (z < n) {last[i] = i; } else {last[i] = last[i+1]; } } int l = -1; for (int i = 0; i < sz; i++) {int z = it -> second[i]; if (z < n) {if (last[i+1] == -1) {D.unite(z, 2 * n); } else {D.unite(z, it -> second[last[i+1]] + n); } } else {if (l == -1) {D.unite(z, 2 * n); } else {D.unite(z, it -> second[l] - n); } l = i; } } ++it; } int q; cin >> q; for (int i = 0; i < q; i ++) {ll x; cin >> x; auto it = s.lower_bound({x % k, x, -1}); if (it == s.end()) {cout << "Yes" << endl; continue; } auto [z, val, idx] = *it; if (z == (x % k)) {if (D.find(idx + n) == D.find(2 * n)) {cout << "YEs" << endl; } else {cout << "No" << endl; } } else {cout << "yES" << endl; } } } signed main() {ios::sync_with_stdio(false); cin.tie(nullptr); ll t = 1; cin >> t; while (t--) {solve(); } return 0; }